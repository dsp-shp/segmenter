# **Сегментер**
*«Автообновляемые и мануально обновляемые сегменты»*

Сегментер – фреймворк, осуществляющий полный цикл приготовления сегмента, начиная с процесса создания или обновления его в источнике и заканчивая передачей его внешним пользователям и системам.

Сегмент здесь – некоторый произвольный набор персональных контактных данных, объединенных вместе по некоторому пользовательскому признаку, создаваемый, хранимый и изменяемый на стороне источника данных – локального хранилища. Копия такого сегмента во внешней системе, например, рекламном кабинете, будет считаться уже не сегментом, а аудиторией.
> *ПРИМЕЧАНИЕ: Фактически, аудитория и сегмент – одно и то же: разграничение на "сегмент" и "аудиторию" в документации используется исключительно для избежания неопределенности в отношении выполняемых над ними действий. Так, обновлением сегмента будет считаться процесс его пересчета на стороне хранилища данных, а обновлением аудитории – загрузка или модификация данных на стороне и методами внешнего пользователя или сервиса.*

Для работы сегментера необходимо создание в базе данных 5 следующих коллекций:
- логовой *"public.segmenter_log"*,
- конфигурационных:
	- *"public.segmenter_segments"* – для сегментов,
	- *"public.segmenter_subscriptions"* – для подписок на сегменты,
	- *"public.segmenter_consumers"* – для подписчиков,
- одной сборной *"public.segmenter"* витрины.

Примеры DDL запросов для их создания можно найти в /source/tables/ директории.
> *ПРИМЕЧАНИЕ: Наименования сервисных объектов в хранилище произвольны – при инициализации объекта-Сегментера параметрами "log_table" и "cfg_table" можно передать любые альтернативные наименования.*

## **Рабочий цикл**
Жизненный цикл сегментера начинается с определения всех актуальных, готовых к рефрешу
1. Для каждого актуального сегмента – ```actual_end = 'infinity'```:
	- проверить 
	- проверить соответстие по ```refresh_cron```
	- проверить прогруженность таблиц источников
	- обновить сегмент соответствующим рефрешером
	- залогировать обновление или ошибку обновления в логовую таблицу
1. Для каждого апдейтера получить перечень аудиторий
1. Для каждого актуального и успешно обновленного сегмента:
	- ...

> *ПРИМЕЧАНИЕ: Сегментер рассчитан на взаимодействие с postgres или postgres-подобными СУБД. Использование любой другой реляционной системой управления возможно при условии корректировки DDL (приведенных чуть ниже), и DML (находящихся в компонентах фреймворка) скриптов под соответствующий SQL диалект.*

## **Добавление сегмента**
Пример сегмента:
```sql
drop table if exists public.test_segment; 
create table public.test_segment (
	segment_id 		uuid 		not null,
	id 				varchar 	null,
	hash_email 		varchar 	null,
	hash_phone 		varchar 	null,
	actual_begin 	timestamp 	not null 	default now(),
	actual_end 		timestamp 	not null 	default 'infinity',
	processed 		timestamp 	not null 	default now(),
	constraint test_segment_id_key unique (id)

);
create index on test_segment using btree(id);
```